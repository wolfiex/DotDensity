<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>DotDensity</title><script defer="defer" src="bundle.d94163f3c9712bb3.js"></script><link href="main.css" rel="stylesheet"></head><body><div id="map"></div><div id="instruction" class="instruction" style="font-size:10%;bottom:4px;position:absolute!important;display:block!important;z-index:99999;color:#fff;width:400px;backdrop-filter:blur(2px)"><span style="font-size:10em!important">Density</span> <input type="range" min="1" max="100" value="80" class="slider" id="densityslider" style="width:100%"/><br/><br/><br/><span style="font-size:10em!important">Colour Thresholds</span><div id="slider"></div><br/>DanielEllisResearch</div></body></html><script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script><style>body{margin:0;padding:0;font-family:'IBM Plex Sans',sans-serif}#map{position:absolute;top:0;bottom:0;width:100%}</style><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@100&display=swap" rel="stylesheet"/><script id="vertexShader" type="x-shader/x-vertex">uniform mat4 u_matrix;
  attribute vec2 a_pos;
  void main() {
      gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);
  }</script><script id="fragmentShader" type="x-shader/x-fragment">precision mediump float;
    precision mediump int;
    // layout(binding = 0, offset = 0) uniform atomic_uint u_counter;

    // uniform vec2 u_resolution;
    uniform float u_density;
    uniform float u_time;
    uniform mat4 u_thresholds;


    //   float rand(vec2 co){

    //     // return fract(sin(dot(co.xy ,vec2(1.9898,1.2323))) * 43758.5453);
    //     return noise  (co.xy, 42);
    // }



    float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio

    float gold_noise(in vec2 co, in float seed){
       return fract(tan(distance(co.xy*PHI, co.xy)*seed)*co.xy.x);
    }

    float show(vec2 co){
    return .7*float(int(u_density>gold_noise(co,142.0)));
    }



    void main() {

    // 5 categories

    vec2 co = gl_FragCoord.xy;
    float showval = show(co);

    if (showval > 0.){

    float thresh = gold_noise(co,42.0);


    if (thresh > u_thresholds[0][3]){
      gl_FragColor = vec4(u_thresholds[0]);
    } else if (thresh > u_thresholds[1][3]){
      gl_FragColor = vec4(u_thresholds[1]);
    } else if (thresh > u_thresholds[2][3]){
      gl_FragColor = vec4(u_thresholds[2]);
    } else if (thresh > u_thresholds[3][3]){
      gl_FragColor = vec4(u_thresholds[3]);
    } else {
      gl_FragColor = vec4(255.,255.,255.,1.);
    }

    // gl_FragColor = ;
    gl_FragColor[3] = showval;
  }
    }</script>